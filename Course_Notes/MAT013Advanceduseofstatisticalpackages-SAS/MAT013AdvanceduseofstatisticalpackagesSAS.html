<html><head><title>MAT013 Advanced use of statistical packages - SAS </title><style type="text/css">ol{margin:0;padding:0}.c50{vertical-align:top;width:84.8pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c42{vertical-align:top;width:214.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c68{vertical-align:top;width:217.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c60{vertical-align:top;width:168pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c38{vertical-align:top;width:228.8pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c35{vertical-align:top;width:167.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c69{vertical-align:top;width:315.8pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c45{vertical-align:top;width:267pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c11{vertical-align:top;width:362.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c66{vertical-align:top;width:255.8pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c61{vertical-align:top;width:270pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c53{vertical-align:top;width:195.8pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c13{vertical-align:top;width:156pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c44{vertical-align:top;width:110.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c55{vertical-align:top;width:312pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c36{vertical-align:top;width:408pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c19{vertical-align:top;width:142.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c49{vertical-align:top;width:380.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c28{vertical-align:top;width:152.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c25{vertical-align:top;width:468pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c63{vertical-align:top;width:193.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c43{vertical-align:top;width:174.8pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c56{vertical-align:top;width:340.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c64{vertical-align:top;width:219.8pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c41{vertical-align:top;width:291pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c10{vertical-align:top;width:313.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c24{vertical-align:top;width:321pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c72{vertical-align:top;width:199.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c70{vertical-align:top;width:198pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c46{vertical-align:top;width:366.8pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c62{vertical-align:top;width:172.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c59{vertical-align:top;width:148.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c21{vertical-align:top;width:234pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c57{vertical-align:top;width:210pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c65{vertical-align:top;width:345pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c54{vertical-align:top;width:115.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c23{vertical-align:top;width:341.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c51{vertical-align:top;width:128.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c33{vertical-align:top;width:188.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c67{vertical-align:top;width:366pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c71{vertical-align:top;width:175.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c20{vertical-align:top;width:220.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c48{vertical-align:top;width:379.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c58{vertical-align:top;width:263.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c18{vertical-align:top;width:248.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c31{margin-right:-55.5pt;text-align:right;padding-bottom:10pt}.c34{list-style-type:circle;margin:0;padding:0}.c17{list-style-type:disc;margin:0;padding:0}.c4{padding-left:0pt;text-align:justify;margin-left:36pt}.c29{list-style-type:decimal;margin:0;padding:0}.c47{margin-right:30pt;margin-left:63pt}.c0{color:#0000ff;font-size:12pt}.c15{padding-left:0pt;margin-left:72pt}.c37{font-size:24pt;text-decoration:underline}.c16{padding-left:0pt;margin-left:36pt}.c52{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c39{height:75pt}.c14{height:0pt}.c3{line-height:1.0}.c9{font-size:14pt}.c8{font-weight:bold}.c2{height:11pt}.c22{font-style:italic}.c12{border-collapse:collapse}.c7{text-align:center}.c40{text-decoration:underline}.c1{direction:ltr}.c30{background-color:#ffffff}.c5{text-align:justify}.c26{height:33pt}.c27{margin-left:36pt}.c6{font-size:12pt}.c32{margin-left:-43.5pt}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:24pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}</style></head><body class="c30 c52"><div><p class="c2 c1 c32"><span class="c6"></span></p><p class="c1 c32"><img height="66" src="images/image14.jpg" width="68"></p></div><p class="c7 c1"><span class="c9 c8 c40">MAT013 Advanced use of statistical packages - SAS</span></p><p class="c2 c7 c1"><span class="c9 c8 c40"></span></p><p class="c1"><span class="c9">Chapter 1 - Introduction </span></p><p class="c2 c1"><span class="c9"></span></p><ol class="c29" start="1"><li class="c16 c1"><span class="c9">The environment</span></li><li class="c16 c1"><span class="c9">Libraries</span></li><li class="c16 c1"><span class="c9">Importing data</span></li><li class="c16 c1"><span class="c9">Exporting data</span></li></ol><p class="c2 c1"><span class="c9"></span></p><p class="c1"><span class="c9">Chapter 2 - Basic Statistical Procedures</span></p><p class="c2 c1"><span class="c9"></span></p><ol class="c29" start="1"><li class="c16 c1"><span class="c9">Procedures</span></li><li class="c16 c1"><span class="c9">A list of procedures</span></li><li class="c16 c1"><span class="c9">Exporting output</span></li></ol><p class="c2 c1"><span class="c9"></span></p><p class="c1"><span class="c9">Chapter 3 - Manipulating Data</span></p><p class="c2 c1"><span class="c9"></span></p><ol class="c29" start="1"><li class="c16 c1"><span class="c9">Data steps</span></li><li class="c16 c1"><span class="c9">The program data vector</span></li><li class="c16 c1"><span class="c9">Creating new variables</span></li><li class="c16 c1"><span class="c9">Handling dates</span></li></ol><p class="c2 c1"><span class="c9"></span></p><p class="c1"><span class="c9">Chapter 4 - Programming</span></p><p class="c2 c1"><span class="c9"></span></p><ol class="c29" start="1"><li class="c16 c1"><span class="c9">Flow control</span></li><li class="c16 c1"><span class="c9">SAS Macro compiler</span></li><li class="c1 c16"><span class="c9">Global and local macro variables</span></li><li class="c16 c1"><span class="c9">Macro Programming Statements </span></li><li class="c16 c1"><span class="c9">Macro Functions</span></li></ol><p class="c2 c1"><span class="c9"></span></p><p class="c1"><span class="c9">Chapter 5 - SAS SQL</span></p><ol class="c29" start="1"><li class="c16 c1"><span class="c9">Basic SQL</span></li><li class="c16 c1"><span class="c9">Further SQL</span></li><li class="c16 c1"><span class="c9">Joining tables in SQL</span></li></ol><p class="c2 c1"><span class="c9"></span></p><p class="c2 c1"><span class="c9"></span></p><p class="c2 c1"><span class="c9"></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c1"><span class="c9"></span></p><p class="c7 c1"><span class="c37">Chapter 1 - Introduction</span><hr style="page-break-before:always;display:none;"></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">1.1 The Environment</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">SAS may be run in a variety of modes, on this course we will concentrate on the interactive mode which allows users to submit selected portions of SAS code through a graphical user interface (GUI). When opening SAS a variety of windows immediately become visible as shown in Figure 1. Note that the screenshots and accompanying screen casts for this course were produced with SAS 9.3 running on ubuntu 11.10. The look and feel on other operating systems will differ slightly.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1"><img height="467" src="images/image21.png" width="635"></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c7 c1"><span class="c8 c6">Figure 1.1. The SAS Environment</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">Figure 1.1 shows the basic SAS environment, the visible windows are:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">The explorer window</span></li><li class="c4 c1"><span class="c6">The results window</span></li><li class="c4 c1"><span class="c6">The command window</span></li><li class="c4 c1"><span class="c6">The output window</span></li><li class="c4 c1"><span class="c6">The log window</span></li><li class="c4 c1"><span class="c6">The editor window</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We write code directly in the editor window and the roles of the other windows will become clear shortly.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1"><span class="c8 c6">1.2 Libraries</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The major strength of SAS is its ability to handle huge data sets. SAS does this by storing files in a particular format in spaces called libraries. SAS libraries are important. SAS manipulates data sets once they are converted to </span><span class="c8 c6">SAS data files</span><span class="c6">. These data files are saved in libraries in SAS. They work just like folders (apart from not being able to nest further libraries). If you click on the libraries tab in the explorer window (as shown in Figure 1.2) you should see the libraries available to you (as shown in Figure 1.3).</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="358" src="images/image58.png" width="290"></p><p class="c7 c1"><span class="c8 c6">Figure 1.2. A closer look at the explorer window</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c7 c1"><img height="290" src="images/image32.png" width="217"></p><p class="c7 c1"><span class="c8 c6">Figure 1.3. The original set of libraries on a linux install</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">On my system SAS has already created 6 libraries (this might differ on other versions and operating systems). The </span><span class="c8 c6">Work </span><span class="c6">library which SAS automatically uses if no library is specified (more on this later, it&rsquo;s basically the default library). A very important fact about the </span><span class="c8 c6">Work</span><span class="c6">&nbsp;library is that it is temporary. </span><span class="c8 c6">When SAS is shut down, all the contents of the Work library are deleted.</span><span class="c6">&nbsp;Keeping this in mind, let&rsquo;s move on to creating a new library.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c8 c6">Creating a new library</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">To create a new library, left click in the explorer window and select &ldquo;New...&rdquo;. You will see a new window appear as shown in Figure 1.4. Simply browse to the location on your computer at which you&rsquo;d like your new library to be stored. Note also to click the </span><span class="c8 c6">&ldquo;Enable at startup&rdquo; </span><span class="c6">option which ensures that SAS remembers this library the next time you open up SAS; if this is not selected, the link to the library created will be temporary (and erased when SAS is shut down). Finally make sure you name your library obeying the following rules (for the rest of the notes, I&rsquo;ll assume the library name for this course is &lsquo;mat008&rsquo;):</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">be less than or equal to 8 characters</span></li><li class="c4 c1"><span class="c6">must begin with an underscore or letter</span></li><li class="c4 c1"><span class="c6">remaining characters can be letters, numbers or underscores</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="370" src="images/image57.png" width="415"></p><p class="c7 c1"><span class="c8 c6">Figure 1.4. New library window</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1"><span class="c6">Now that we have a library let&rsquo;s import some data!</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">1.3 Importing Data</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">There are two main ways to import data into SAS:</span></p><p class="c2 c1"><span class="c6"></span></p><ol class="c17" start="1"><li class="c16 c1"><span class="c6">Direct input </span></li><li class="c16 c1"><span class="c6">Importing an external data set (xls, csv etc...)</span></li></ol><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">In practice you will never use the direct input method but let&rsquo;s take a look for completeness (although it is very useful when wanting to quickly test a few things). This will also give us our first experience of the editor window!</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"><br></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Let us create a data set named &ldquo;first_data_set&rdquo;, put it in the</span><span class="c6">&nbsp;&ldquo;MAT008&rdquo; </span><span class="c6">library and include the following data:</span></p><p class="c2 c1"><span class="c6"></span></p><a href="#" name="0c8f25d8b7b9bbcc34f35b7694370d72b25aae64"></a><a href="#" name="0"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr><td class="c21"><p class="c3 c7 c1"><span class="c6">Name</span></p></td><td class="c21"><p class="c3 c1 c7"><span class="c6">Age</span></p></td></tr><tr><td class="c21"><p class="c3 c7 c1"><span class="c6">Bob</span></p></td><td class="c21"><p class="c3 c7 c1"><span class="c6">23</span></p></td></tr><tr><td class="c21"><p class="c3 c7 c1"><span class="c6">Billy</span></p></td><td class="c21"><p class="c3 c7 c1"><span class="c6">25</span></p></td></tr></tbody></table><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1"><span class="c6">To do so, write the following code in the editor window (for the purpose of the course, code will be written in blue):</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="706a5ec26ab1464a6b27d60807bfe84280d4a7cb"></a><a href="#" name="1"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr><td class="c71"><p class="c3 c1"><span class="c0">data MAT008.first_data_set;</span></p><p class="c3 c1"><span class="c0">input Name $ Age;</span></p><p class="c3 c1"><span class="c0">cards;</span></p><p class="c3 c1"><span class="c0">Bob 23</span></p><p class="c3 c1"><span class="c0">Billy 25</span></p><p class="c3 c1"><span class="c0">;</span></p><p class="c3 c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c6">Let&rsquo;s take a look at the screenshot in Figure 1.5. First of all we see that the program editor automatically includes some syntax colouring (i.e. changes the colour of some of the words that it recognises). In blue in the editor window are the SAS keywords: </span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">&ldquo;data&rdquo; which tells SAS that we&rsquo;re about to write a &ldquo;data step&rdquo; which we&rsquo;ll look at a bit closer in the Chapter 3. The keyword data is always followed by the library and the data file (separated by a &ldquo;.&rdquo;) &nbsp;we&rsquo;re creating. If no library is given then SAS will put this file in the Work library. </span></li><li class="c4 c1"><span class="c6">&ldquo;input&rdquo; which tells SAS that we&rsquo;re going to input raw data and what follows is the name of the variables. If a variable is a string then we must include a &ldquo;$&rdquo; after the variable name.</span></li><li class="c4 c1"><span class="c6">&ldquo;cards&rdquo; which is the SAS keyword that precedes the raw data. All the entries must be on separate rows.</span></li><li class="c4 c1"><span class="c6">&ldquo;run&rdquo; which is the keyword that tells SAS where the statement ends.</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">An important thing to remember is that a SAS statement always ends with a &ldquo;;&rdquo;. </span><span class="c8 c6">Forgetting the &ldquo;;&rdquo; is a common source of mistakes (and headaches).</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><img height="295" src="images/image60.png" width="609"></p><p class="c7 c1"><span class="c8 c6">Figure 1.5. A short program to directly input data in to SAS.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We run this code by highlighting it and pressing the &lsquo;running man&rsquo;, clicking on run (or pressing F8 on Windows). It is good practice to always check the log window as soon as any code is run. In Figure 1.6 we see that the log looks good (lines 1-7 don&rsquo;t show any errors) and simply gives some details as to the running of the program.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="267" src="images/image35.png" width="412"></p><p class="c7 c1"><span class="c8 c6">Figure 1.6. A short program to directly input data in to SAS.</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1"><span class="c6">If we now look at the MAT008 library in the explorer pane we can see the new data set is in there (Figure 1.7), double clicking on the data set opens it up (Figure 1.8).</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="390" src="images/image26.png" width="243"></p><p class="c7 c1"><span class="c8 c6">Figure 1.7. The explorer pane with our first data set.</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c7 c1"><img height="307" src="images/image42.png" width="304"></p><p class="c7 c1"><span class="c8 c6">Figure 1.8. Viewing our first data set.</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1"><span class="c6">Using direct input is of course not at all realistic when trying to import larger data sets.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Often large data sets will be saved in comma-separated values (csv) format which can be read by most (all?) software. We will import the data set shown in Figure 1.9 (here viewed in a simple text editor).</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="229" src="images/image13.png" width="632"></p><p class="c7 c1"><span class="c8 c6">Figure 1.9 The JJJ.csv data set</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">We will import this data set in to the MAT008 library and call it JJJ using the following code:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="be6c4834b9aeded2481eb864bb7f9b63d29aa67b"></a><a href="#" name="2"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c63"><p class="c1"><span class="c0">proc import datafile=&quot;~/JJJ.csv&quot;<br> &nbsp; &nbsp; out=mat008.</span><span class="c0">JJJ</span><span class="c0"><br> &nbsp; &nbsp; dbms=csv<br> &nbsp; &nbsp; replace;<br> &nbsp; &nbsp; getnames=yes;<br>run;</span></p></td></tr></tbody></table><p class="c3 c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Let&rsquo;s take a look at the screenshot in Figure 1.10. &nbsp;We again see (as for Figure 1.5) that the program editor automatically includes some syntax colouring (i.e. changes the colour of some of the words that it recognises). In blue in the editor window are the SAS keywords: </span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="5"><li class="c4 c1"><span class="c6">&ldquo;proc&rdquo; which tells SAS that we&rsquo;re about to write a &ldquo;procedure step&rdquo; which we&rsquo;ll look at a bit closer in the next chapter. The &ldquo;proc&rdquo; keyword is always followed by the name of the particular procedure we&rsquo;re going to use. In this case: &ldquo;import&rdquo;, which is then followed by the statement &ldquo;datafile=path-to-datafile&rdquo;. Following this are various options relating to the import statement.</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c34" start="1"><li class="c15 c1 c5"><span class="c6">&ldquo;out&rdquo; - this tells SAS the name of the SAS datafile created from the imported file.</span></li><li class="c15 c1 c5"><span class="c6">&ldquo;dbms&rdquo; - this tells SAS the type of file being imported (in our case csv, but can be &ldquo;dlm&rdquo;, &ldquo;xls&rdquo;, etc.). Note that this is not necessary if SAS can recognise the file extension.</span></li><li class="c15 c1 c5"><span class="c6">&ldquo;replace&rdquo; - this tells SAS to replace any SAS datafiles with the same name as specified by &ldquo;out&rdquo;.</span></li></ol><p class="c2 c1 c5 c27"><span class="c6"></span></p><ol class="c17" start="6"><li class="c4 c1"><span class="c6">&ldquo;getnames=yes&rdquo; which, although this is not a SAS keyword, it is a special option for the import statement that allows you to tell SAS to get the variable names from the first row of your external data file.</span></li><li class="c4 c1"><span class="c6">&ldquo;run&rdquo; is the keyword that tells SAS where the statement ends.</span></li></ol><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c7 c1"><img height="243" src="images/image62.png" width="642"></p><p class="c3 c2 c7 c1"><span class="c6"></span></p><p class="c3 c7 c1"><span class="c8 c6">Figure 1.10 A short program to import a csv file in to SAS.</span></p><p class="c3 c2 c7 c1"><span class="c8 c6"></span></p><p class="c3 c1"><span class="c6">Running the code in the same way as before (highlighting and F8) will create the required datafile as shown in Figures 1.11 and 1.12.</span></p><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c7 c1"><img height="298" src="images/image05.png" width="281"></p><p class="c3 c7 c1"><span class="c8 c6">Figure 1.11. The explorer pane with our JJJ data set.</span></p><p class="c3 c2 c7 c1"><span class="c6"></span></p><p class="c3 c7 c1"><img height="204" src="images/image31.png" width="604"></p><p class="c3 c7 c1"><span class="c8 c6">Figure 1.12. Viewing the JJJ data set.</span></p><p class="c3 c2 c7 c1"><span class="c6"></span></p><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c1"><span class="c6">In the following chapters we will learn how to create new data sets from old data sets and as such it may become necessary to export files to csv.</span></p><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c1"><span class="c8 c6">1.3 Exporting data sets</span></p><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c1"><span class="c6">We will export our first data set (&ldquo;mat008/first_dataset&rdquo;) to csv using the following code:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="b27620183c6064532a7495f0e068a9228782d0f1"></a><a href="#" name="3"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c41"><p class="c3 c1"><span class="c0">proc export data=mat008.first_data_set<br> &nbsp; &nbsp; outfile=&rdquo;~/Desktop/first_data_set.csv&rdquo;</span></p><p class="c3 c1"><span class="c0">&nbsp; &nbsp; &nbsp;dbms=csv<br> &nbsp; &nbsp; replace;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Let&rsquo;s take a look at the screenshot in Figure 1.13. &nbsp;We again see (as for Figure 1.10 and 1.5) that the program editor automatically includes some syntax colouring (i.e. changes the colour of some of the words that it recognises). In blue are the SAS keywords: </span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="8"><li class="c4 c1"><span class="c6">&ldquo;proc&rdquo; which tells SAS that we&rsquo;re about to write a &ldquo;procedure step&rdquo; which we&rsquo;ll look at a bit closer in the next chapter. The &ldquo;proc&rdquo; keyword is always followed by the name of the particular procedure we&rsquo;re going to use. In this case: &ldquo;export&rdquo;, which is then followed by the statement &ldquo;data=&rdquo; followed by the library and name of the SAS data file you want to export. Following this are various options relating to the export statement.</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c34" start="1"><li class="c15 c1 c5"><span class="c6">&ldquo;outfile&rdquo; - this tells SAS where the exported file should go.</span></li><li class="c15 c1 c5"><span class="c6">&ldquo;dbms&rdquo; - this tells SAS the type of file to create when exporting (in our case csv, but can be &ldquo;dlm&rdquo;, &ldquo;xls&rdquo;, etc...). Note that this is not necessary if SAS can recognise the file extension.</span></li><li class="c15 c1 c5"><span class="c6">&ldquo;replace&rdquo; - this tells SAS to replace any file with the same name as specified by &ldquo;outfile&rdquo;.</span></li></ol><p class="c2 c1 c5 c27"><span class="c6"></span></p><ol class="c17" start="9"><li class="c4 c1"><span class="c6">&ldquo;run&rdquo; is the keyword that tells SAS where the statement ends.</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="239" src="images/image56.png" width="583"></p><p class="c7 c1"><span class="c8 c6">Figure 1.13. A short program to export a SAS data file to csv.</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1"><span class="c6">In the next chapter we will see more complex (and potentially useful) procedures.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c37"></span></p><p class="c2 c1"><span class="c37"></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c1"><span class="c37"></span></p><p class="c7 c1"><span class="c37">Chapter 2 - Basic Statistical Procedures</span></p><hr style="page-break-before:always;display:none;"><p class="c2 c7 c1"><span class="c37"></span></p><p class="c1"><span class="c8 c6">2.1 Procedures</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">In the previous chapter we were introduced to some very basic aspects of SAS:</span></p><p class="c2 c1"><span class="c6"></span></p><ol class="c17" start="1"><li class="c16 c1"><span class="c6">what SAS looks like</span></li><li class="c16 c1"><span class="c6">how to import data into SAS</span></li><li class="c16 c1"><span class="c6">how to export data from SAS</span></li></ol><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">In this chapter we will take a closer look at &ldquo;procedure steps&rdquo; which allow us to call a SAS procedure to analyse or process a SAS dataset. In the previous chapter we have already seen two procedure steps:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">proc import</span></li><li class="c4 c1"><span class="c6">proc export</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c8 c30 c6"></span></p><p class="c1 c5"><span class="c6">The procedures we are going to look at in this chapter are:</span></p><p class="c2 c1"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">Viewing datasets</span></li><li class="c4 c1"><span class="c6">Summarising the contents of data sets</span></li><li class="c4 c1"><span class="c6">Obtaining summary statistics of data sets</span></li><li class="c4 c1"><span class="c6">Obtaining frequency tables</span></li><li class="c4 c1"><span class="c6">Obtaining linear models</span></li><li class="c4 c1"><span class="c6">Plotting data</span></li></ol><p class="c2 c1"><span class="c8 c6 c30"></span></p><p class="c2 c1 c5"><span class="c8 c30 c6"></span></p><p class="c1 c5"><span class="c6">The general syntax for these procedures in SAS is given below:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="d440ff06db18249c59c33b17a0700793b46c4582"></a><a href="#" name="4"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c3 c1"><span class="c0">proc [NAME OF PROCEDURE] data=[NAME OF SAS DATA SET];</span></p><p class="c3 c1"><span class="c0">[Options for Procedure being used]<br>run;</span></p></td></tr></tbody></table><p class="c3 c2 c1"><span class="c8 c6"></span></p><p class="c3 c1"><span class="c6">Some of the options that can be used in a procedure step include:</span></p><p class="c3 c2 c1"><span class="c6"></span></p><ol class="c17" start="1"><li class="c16 c3 c1"><span class="c6">&ldquo;var&rdquo; - which tells SAS which variables are to be processed.</span></li><li class="c16 c3 c1"><span class="c6">&ldquo;by&rdquo; - which tells SAS to compartementalize the procedure for each different value of the named variable(s). </span><span class="c8 c6">The data set must first be sorted by those variables</span><span class="c6">.</span></li><li class="c16 c3 c1"><span class="c6">&ldquo;where&rdquo; - select only those observations for which the expression is true.</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c8 c6">2.2 A list of procedures</span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c8 c6">Utility procedures</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">We have already seen that we can open and view a data set by simply double clicking on the data set in the explorer window. A data set can also be viewed by using the &ldquo;print&rdquo; procedure.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">We&rsquo;ll do this by considering the MMM data file shown in Figure 2.1 (imported using an import procedure).</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="224" src="images/image41.png" width="665"></p><p class="c7 c1"><span class="c8 c6">Figure 2.1. The mat008.mmm data set.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">The following code will run the &ldquo;print&rdquo; procedure:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="18de116a148cd084fb9e5e43b8673ddc03da77af"></a><a href="#" name="5"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c41"><p class="c3 c1"><span class="c0">proc print data=mat008.mmm;<br>run;</span></p></td></tr></tbody></table><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c1"><span class="c6">which outputs the data set to the output window (recall Figure 1.1) as shown in Figure 2.2.</span></p><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c7 c1"><img height="328" src="images/image24.png" width="645"></p><p class="c3 c7 c1"><span class="c8 c6">Figure 2.2 The mat008.mmm shown using the &ldquo;print&rdquo; procedure.</span></p><p class="c3 c2 c1 c5"><span class="c6"></span></p><p class="c3 c1 c5"><span class="c6">At times we might not want to open the data set but simply gain some information as to what is in the data set. </span><span class="c22 c6">This is equivalent to checking the label on a present without unwrapping it.</span><span class="c6">&nbsp;We do this using the &ldquo;contents&rdquo; procedure.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="160ee7950bcfc6a6676731a9d4c58cd88792fa30"></a><a href="#" name="6"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c70"><p class="c3 c1 c5"><span class="c0">proc contents data=mat008.mmm;<br>run;</span></p></td></tr></tbody></table><p class="c3 c1"><span class="c6">&nbsp;</span></p><p class="c3 c1"><span class="c6">This outputs summary information as shown in Figure 2.3.</span></p><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c7 c1"><img height="287" src="images/image59.png" width="564"></p><p class="c3 c2 c1"><span class="c8 c6"></span></p><p class="c3 c7 c1"><span class="c8 c6">Figure 2.3 Summary information regarding mat008.mmm viewed using the contents procedure.</span></p><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c1"><span class="c6">A procedure that will be needed, when using more complex procedures and larger data sets, is the &ldquo;sort&rdquo; procedure.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="547d28bbc936e623ed4551b58178d02507d94453"></a><a href="#" name="7"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c60"><p class="c3 c1"><span class="c0">proc sort data=mat008.mmm;<br>by age;</span></p><p class="c3 c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c3 c2 c1 c5"><span class="c8 c6"></span></p><p class="c3 c1 c5"><span class="c6">Note that this procedure makes use of the &ldquo;by&rdquo; statement which tells SAS which variable to sort our observations on (in this case the variable age). Recalling Figure 2.2, the &nbsp;data set is not sorted. If we run the above &ldquo;sort&rdquo; procedure, at first nothing seems to happen, however if we view the data set again (using proc print or otherwise) we see (as shown in Figure 2.4) that the data set is now sorted.</span></p><p class="c3 c2 c1 c5"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c7 c1"><img height="295" src="images/image06.png" width="579"></p><p class="c7 c1"><span class="c8 c6">Figure 2.4 The mat008.mmm sorted by the Age variable.</span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c8 c6">Important: </span><span class="c6">If you have the mat008.mmm data set open in browser mode (i.e. having double clicked on the data set in the explorer window) when running the &ldquo;sort&rdquo; procedure, checking your log shows you an error as seen in Figure 2.5. </span><span class="c8 c6">Always close any browser windows when processing a data set - or use the &ldquo;print&rdquo; procedure!</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="204" src="images/image20.png" width="595"></p><p class="c7 c1"><span class="c8 c6">Figure 2.5 Error associated with trying to manipulate a data set that is open in browser mode.</span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c8 c6">Descriptive statistics</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">In this section we will go over some of the procedures needed to obtain descriptive statistics.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The first procedure we consider is the &ldquo;means&rdquo; procedure. We can use the following code to obtain various summary statistics relating to the age variables of the mat008.mmm dataset.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="76058e4ef5d5a6ba2f3276386d371983086efd81"></a><a href="#" name="8"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c3 c1"><span class="c0">proc means data=mat008.mmm;</span></p><p class="c3 c1"><span class="c0">var age;<br>run;</span></p></td></tr></tbody></table><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c1"><span class="c6">We can specify the particular summary statistics we want (if none are specified a default set is displayed). </span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="14f92aadf2e146f57ba720e0758ccaf308d9cbff"></a><a href="#" name="9"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c3 c1"><span class="c0">proc means data=mat008.mmm N mean std min max sum var css uss;</span></p><p class="c3 c1"><span class="c0">var age;<br>run;</span></p></td></tr></tbody></table><p class="c3 c2 c1"><span class="c6"></span></p><p class="c3 c1"><span class="c6">We can also choose to display the summary statistics for more than one variable</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="94c20813e0353f61334170cbf21fb12c4d5f7aa1"></a><a href="#" name="10"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c3 c1"><span class="c0">proc means data=mat008.mmm N mean std min max sum var css uss;</span></p><p class="c1"><span class="c0">var age height_in_metres;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">We can compartmentalise our data results using the &ldquo;by&rdquo; statement. </span><span class="c8 c6">Note that the data set must be sorted on the same variable.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="8638e442a86a426218145a0d9b3232e92c02215f"></a><a href="#" name="11"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c3 c1"><span class="c0">proc means data=mat008.mmm N mean std min max sum var css uss;</span></p><p class="c1"><span class="c0">var age height_in_metres;</span></p><p class="c1"><span class="c0">by sex;<br>run;</span></p></td></tr></tbody></table><p class="c3 c2 c1"><span class="c8 c6"></span></p><p class="c3 c1"><span class="c6">Another way of compartmentalising results is using the &ldquo;class&rdquo; statement. This is very similar to the &ldquo;by&rdquo; statement and does not require the prior sorting of your data set.</span></p><p class="c3 c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="c92757bf59c4c263c957af08103cd4bacd8600c8"></a><a href="#" name="12"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c3 c1"><span class="c0">proc means data=mat008.mmm N mean std min max sum var css uss;</span></p><p class="c1"><span class="c0">var age height_in_metres;</span></p><p class="c3 c1"><span class="c0">class sex;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c3 c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">Finally, it&rsquo;s also possible to create a data set from the &ldquo;means&rdquo; procedure. </span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="7d167bc86921275dd56f14bb7aef235d46831e1e"></a><a href="#" name="13"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c66"><p class="c3 c1"><span class="c0">proc means data=mat008.mmm N mean;</span></p><p class="c1"><span class="c0">var age height_in_metres;</span></p><p class="c1"><span class="c0">class sex;</span></p><p class="c1"><span class="c0">output out=summary_of_mmm </span></p><p class="c1"><span class="c0">N(age)=number_of_age_obs </span></p><p class="c1"><span class="c0">mean(age)=average_of_age_obs </span></p><p class="c1"><span class="c0">N(height_in_metres)=number_of_height_obs </span></p><p class="c1"><span class="c0">mean(height_in_metres)=average_height;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The above code creates a data set called &ldquo;summary_of_mmm&rdquo; in the work library (the default library if no library is specified) with two variables &ldquo;number_of_obs&rdquo; and &ldquo;average_of_obs&rdquo; which give the number and mean for the observations as calculated by the &ldquo;means&rdquo; procedure. Figure 2.6 gives a screenshot of this.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="188" src="images/image16.png" width="594"></p><p class="c7 c1"><span class="c8 c6">Figure 2.6 Data set created using the &ldquo;means&rdquo; procedure</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The &ldquo;univariate&rdquo; procedure allows for the calculation of univariate statistics in SAS. The following code will output all the default univariate statistics for all the variables.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="6b7338bf603589fdb3f034f570c5d136b9e03daa"></a><a href="#" name="14"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c45"><p class="c1"><span class="c0">proc univariate data=mat008.mmm;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">We can choose to run the &ldquo;univariate&rdquo; procedure on a subset of the variables, using the &ldquo;var&rdquo; statement.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="8ce6c85b08bc18a62ceb901b98331159480b8e11"></a><a href="#" name="15"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c45"><p class="c1"><span class="c0">proc univariate data=mat008.mmm;</span></p><p class="c1"><span class="c0">var savings_in_pounds;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The various outputs of the &ldquo;univariate&rdquo; procedure are shown in Figure 2.7a, 2.7b, 2.7c, 2.7d and 2.7e.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="331" src="images/image10.png" width="591"></p><p class="c7 c1"><span class="c8 c6">Figure 2.7a Moments calculated using proc univariate.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c7 c1"><img height="321" src="images/image03.png" width="573"></p><p class="c7 c1"><span class="c8 c6">Figure 2.7b Basic measures of location calculated using proc univariate.</span></p><p class="c7 c1"><img height="356" src="images/image61.png" width="590"></p><p class="c7 c1"><span class="c8 c6">Figure 2.7c Tests for location calculated using proc univariate.</span></p><p class="c7 c1"><img height="350" src="images/image53.png" width="580"></p><p class="c7 c1"><span class="c8 c6">Figure 2.7d Quantiles calculated using proc univariate.</span></p><p class="c7 c1"><img height="364" src="images/image36.png" width="603"></p><p class="c7 c1"><span class="c8 c6">Figure 2.7e Extreme values calculated using proc univariate.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">Frequency tables</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">The &ldquo;freq&rdquo; procedure allows us to obtain frequency tables of data sets. As an example, let&rsquo;s consider the dataset shown in Figure 2.8.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="283" src="images/image27.png" width="292"></p><p class="c7 c1"><span class="c8 c6">Figure 2.8 The data set Math_tests.csv</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The most basic &ldquo;freq&rdquo; procedure will give the frequencies of all the observations in the data set:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="5978a8fac292697a2c442cddfaff8abb5da4338c"></a><a href="#" name="16"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c53"><p class="c3 c1"><span class="c0">proc freq data=mat008.math_tests;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We can specify the variables we want to look at by listing them after the &ldquo;tables&rdquo; statement (similar to the var statement for the &ldquo;means&rdquo; procedure):</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="e98955a62bc45d512cd6cec6e8c1c2ca724e126d"></a><a href="#" name="17"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c72"><p class="c1"><span class="c0">proc freq data=mat008.math_tests;<br>tables teacher pass_fail;</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c3 c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">If we want to cross tabulate the data then we use a &ldquo;*&rdquo; in between the variables concerned:</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="adb5f665ad37868b27171a955bd5d95dcbff4540"></a><a href="#" name="18"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c1"><span class="c0">proc freq data=mat008.math_tests;<br>tables teacher*pass_fail;</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The above code gives the table shown in Figure 2.9.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="354" src="images/image08.png" width="620"></p><p class="c7 c1"><span class="c8 c6">Figure 2.9 Frequency table for the math_tests data set.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">Various options can be passed to the &ldquo;freq&rdquo; procedure, the simplest of which is shown below:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="cbc18fdb02a19b7a6afc9099fe38178b24fbb7f2"></a><a href="#" name="19"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c69"><p class="c1"><span class="c0">proc freq data=mat008.math_tests;<br>tables teacher*pass_fail / nocol norow nopercent;</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">Other options include computing a chi square test but we will not worry about that for now.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c8 c6">Correlations</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The &ldquo;corr&rdquo; procedure can be used to obtain correlations in SAS. The following code is the basic &rdquo;corr&rdquo; procedure applied to the mat008.mmm data set which gives the output shown in Figure 2.10.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="f0befc9d12bf801747f2038f411a8678ae06fd4f"></a><a href="#" name="20"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c43"><p class="c1"><span class="c0">proc corr data=mat008.mmm;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="354" src="images/image49.png" width="641"></p><p class="c7 c1"><span class="c8 c6">Figure 2.10 Output of the &ldquo;corr&rdquo; procedure acting on all the variables of the mat008.mmm data set</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">If we want to run the &ldquo;corr&rdquo; procedure on a subset of the variables then we use the &ldquo;var&rdquo; statement:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="e41c5496b6e4b644f37bb5388a39689e3f541471"></a><a href="#" name="21"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c43"><p class="c1"><span class="c0">proc corr data=mat008.mmm;</span></p><p class="c1"><span class="c0">var age savings_in_pounds;<br>run;</span></p></td></tr></tbody></table><p class="c1"><img height="372" src="images/image22.png" width="674"></p><p class="c7 c1"><span class="c8 c6">Figure 2.11 Output of the &ldquo;corr&rdquo; procedure acting on a subset of the mat008.mmm data set</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">Linear Models</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">In this section we&rsquo;ll very briefly see the syntax for some basic linear models in SAS. First of all we&rsquo;ll take a look at linear regression. The following code will run such an analysis on the mat008.jjj data set, checking if there is a linear model of height with predictors weight and savings:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="7bea447bd01f5e6a69c52d7ab6b6b3daf2bbd176"></a><a href="#" name="22"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">proc reg data=mat008.jjj;</span></p><p class="c1"><span class="c0">model height_in_metres=weight_in_kg savings_in_pounds;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">Figures 2.12a and 2.12b show the output of the model.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c7 c1"><img height="379" src="images/image12.png" width="604"></p><p class="c7 c1"><span class="c8 c6">Figure 2.12a Overall regression results</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c7 c1"><img height="378" src="images/image39.png" width="602"></p><p class="c7 c1"><span class="c8 c6">Figure 2.12b Detailed regression results</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">Looking at the p-value in Figure 2.12a we see that the </span><span class="c6">overall model should not be rejected,</span><span class="c6">&nbsp;however the detailed results of Figure 2.12b show that perhaps we could remove savings from the model.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Analysis of variance (ANOVA) can be done very easily in SAS. We show this using a new data set given in Figure 2.13.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="373" src="images/image09.png" width="283"></p><p class="c7 c1"><span class="c8 c6">Figure 2.13 The math.csv data set</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">We will use the &ldquo;anova&rdquo; procedure to see if the grades obtained by students depend on their teacher.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="17fea3320c25291a15736b4dbf98340c891eaf55"></a><a href="#" name="23"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">proc anova data=mat008.math;</span></p><p class="c1 c5"><span class="c0">class prof;</span></p><p class="c1 c5"><span class="c0">model grade=prof;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Note the &ldquo;class&rdquo; keyword is needed to state which variable we are using to group on. The results are shown in Figure 2.14, showing that there is indeed a difference between groups (furher post-hoc tests are needed to investigate which groups differ etc.).</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="391" src="images/image25.png" width="623"></p><p class="c7 c1"><span class="c8 c6">Figure 2.14 Overall Results from the ANOVA.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">Another procedure that can be used for a variety of models (including the 2-way anova) is the &ldquo;glm&rdquo; (general linear model) procedure. The following code simply reproduces the above results.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="b2de969de3db81dfaa607c30769b72e7eba06fbb"></a><a href="#" name="24"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">proc glm data=mat008.jjj;</span></p><p class="c1 c5"><span class="c0">model height_in_metres=weight_in_kg savings_in_pounds;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="0e8054830c1df198f3e3447a26ea73fb417c2e4f"></a><a href="#" name="25"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">proc glm data=mat008.math;</span></p><p class="c1 c5"><span class="c0">class prof;</span></p><p class="c1 c5"><span class="c0">model grade=prof;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">Plots and charts</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">There are various ways to obtain histograms in SAS, the easiest way is to use the &ldquo;univariate&rdquo; procedure with the &ldquo;histogram&rdquo; option. The following code gives a histogram for the height of individuals in the mat008.jjj dataset as shown in Figure 2.15.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="037c97be4bd3e9d81807106273f5d994b827f406"></a><a href="#" name="26"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">proc univariate data=mat008.jjj;</span></p><p class="c1 c5"><span class="c0">var height_in_metres;</span></p><p class="c1"><span class="c0">histogram;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="387" src="images/image01.png" width="602"></p><p class="c7 c1"><span class="c8 c6">Figure 2.15 A histogram obtained using the &ldquo;univariate&rdquo; procedure.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">There are various ways to obtain scatter plots in SAS, the easiest way is to use the &ldquo;gplot&rdquo; procedure. The following code gives a scatter plot for the height of individuals against their weight in the mat008.jjj dataset as shown in Figure 2.16.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="8f8f1c5542fcaf664488669267d45651d09a1447"></a><a href="#" name="27"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">proc gplot data=mat008.jjj;</span></p><p class="c1 c5"><span class="c0">plot height_in_metres*weight_in_kg;<br>run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c8 c6"></span></p><p class="c7 c1"><img height="362" src="images/image28.png" width="563"></p><p class="c7 c1"><span class="c8 c6">Figure 2.16 A scatter obtained using the &ldquo;gplot&rdquo; procedure.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">There are various other ways to obtain similar graphs as well as change the look and feel of our graphs. We won&rsquo;t go into this here but you are encouraged to look into it.</span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">2.3 Exporting output</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We can output results of procedures in SAS using the &ldquo;output delivery system&rdquo;. The syntax is straightforward and we surround normal SAS code with the &ldquo;ods&rdquo; statements to output to various formats (html, pdf, rtf).</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="e0739eb7b1e69ba4b09c781d2ffca77e1622ac4b"></a><a href="#" name="28"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">ods [format of your choice] file=[Location of file to be output];</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">[Normal SAS code]</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">ods [format of your choice] close;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">As an example, the following code creates an html file called &ldquo;freq_table&rdquo; in html format stored at the location &ldquo;~/Desktop&rdquo; (note that in Window&rsquo;s the &ldquo;/&rdquo; should be a &ldquo;\&rdquo;) as shown in Figure 2.17.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="d85e856f0c71bd9e41bd5c13b340f5b1cdd884b1"></a><a href="#" name="29"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">ods html file=&rdquo;~/Desktop/freq_table.htm&rdquo;;</span></p><p class="c1 c5"><span class="c0">proc gplot data=mat008.jjj;</span></p><p class="c1 c5"><span class="c0">plot height_in_metres*weight_in_kg;<br>run;</span></p><p class="c1 c5"><span class="c0">ods html close;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><img height="406" src="images/image17.png" width="651"></p><p class="c7 c1"><span class="c8 c6">Figure 2.17 Ods output in html format.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">The following code will create a file called &ldquo;scatter_plot.pdf&rdquo; in pdf format stored at the location &ldquo;~/Desktop&rdquo; (note that in Window&rsquo;s the &ldquo;/&rdquo; should be a &ldquo;\&rdquo;) as shown in Figure 2.18.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="cdbb9be617b110f12a3c40045891832456691fcd"></a><a href="#" name="30"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">ods pdf file=&rdquo;~/Desktop/scatter_plot.pdf&rdquo;;</span></p><p class="c1 c5"><span class="c0">proc gplot data=mat008.j;</span></p><p class="c1 c5"><span class="c0">plot height_in_metres*weight_in_kg;<br>run;</span></p><p class="c1 c5"><span class="c0">ods pdf close;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="429" src="images/image02.png" width="619"></p><p class="c7 c1"><span class="c8 c6">Figure 2.18 Ods output in pdf format.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">The following code will create a file called &ldquo;regression.rtf&rdquo; in rtf format (Word, LibreOffice etc.) stored at the location &ldquo;~/Desktop&rdquo; (note that in Window&rsquo;s the &ldquo;/&rdquo; should be a &ldquo;\&rdquo;) as shown in Figure 2.19.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="0554e1e2a3cfc0577bac80ed24cfe1aaac0e5b25"></a><a href="#" name="31"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">ods rtf file=&rdquo;~/Desktop/regression.rtf&rdquo;;</span></p><p class="c1 c5"><span class="c0">proc reg data=mat008.jjj;</span></p><p class="c1 c5"><span class="c0">model weight_in_kg=height_in_metres;<br>run;</span></p><p class="c1 c5"><span class="c0">ods rtf close;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c7 c1"><img height="528" src="images/image55.png" width="585"></p><p class="c7 c1"><span class="c8 c6">Figure 2.19 Ods output in rtf format.</span></p><hr style="page-break-before:always;display:none;"><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c7 c1"><span class="c37">Chapter 3 - Manipulating data</span></p><hr style="page-break-before:always;display:none;"><p class="c2 c7 c1"><span class="c37"></span></p><p class="c1"><span class="c8 c6">3.1 Data steps</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">A data step is a type of SAS statement that allows you to manipulate SAS data sets. Some of the things we can do include:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">Copying a data set (with new variables)</span></li><li class="c4 c1"><span class="c6">Concatenating any number of data sets</span></li><li class="c4 c1"><span class="c6">Merging any number of data sets</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The following code simply creates a data set in the work library called &ldquo;J&rdquo; that is a copy of the data set jjj located in the mat008 library.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="7075480486e2d0ffe8bba7532eeae4900422ab99"></a><a href="#" name="32"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c50"><p class="c1 c5"><span class="c0">data j;</span></p><p class="c1 c5"><span class="c0">set mat008.jjj<br>run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">To concatenate two data sets (as shown pictorially in Figure 3.1) we use the following syntax:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="0912dc2b1a2bd0d37f9fa37ebc7ccb721f964919"></a><a href="#" name="33"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c51"><p class="c1 c5"><span class="c0">data [New Data Set];</span></p><p class="c1 c5"><span class="c0">set A B;</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="233" src="images/image00.png" width="529"></p><p class="c7 c1"><span class="c8 c6">Figure 3.1 Concatenating two data sets.</span></p><p class="c1"><span class="c6">The following code concatenates the jjj and mmm data sets as shown in Figure 3.2.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="2e5d2c5c38e0ebe6ec19d89d9c5c2dc9e4ee2da2"></a><a href="#" name="34"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">data mat008.mmmjjj;</span></p><p class="c1 c5"><span class="c0">set mat008.mmm mat008.jjj</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="308" src="images/image54.png" width="565"></p><p class="c7 c1"><span class="c8 c6">Figure 3.2 A concatenated data set.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">To merge two data sets (as shown pictorially in Figure 3.3) we use the following syntax:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="8b1f178c6f8625864722fa2b53f67d9a74e098bd"></a><a href="#" name="35"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">data [New Data Set];</span></p><p class="c1 c5"><span class="c0">merge A B;</span></p><p class="c1 c5"><span class="c0">by [Merge Variable]</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c8 c6">Note that the two data sets </span><span class="c8 c40 c6">must</span><span class="c8 c6">&nbsp;be sorted on the merge variable prior to merging. </span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c7 c1"><img height="189" src="images/image19.png" width="529"></p><p class="c7 c1"><span class="c8 c6">Figure 3.3 Merging two data sets.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">The following code would merge the two data sets first_data_set and other_data_set in the mat008 library as shown in Figure 3.4.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="728d673ddef8505397f74c0f688643e1be29d771"></a><a href="#" name="36"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">proc sort data=mat008.first_data_set;</span></p><p class="c1 c5"><span class="c0">by name;</span></p><p class="c1 c5"><span class="c0">run;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">proc sort data=mat008.other_data_set;</span></p><p class="c1 c5"><span class="c0">by name;</span></p><p class="c1 c5"><span class="c0">run;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">data mat008.merged_data_set;</span></p><p class="c1 c5"><span class="c0">merge mat008.first_data_set mat008.other_data_set;</span></p><p class="c1 c5"><span class="c0">by name;</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="149" src="images/image34.png" width="618"></p><p class="c7 c1"><span class="c8 c6">Figure 3.4 A merged data set.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">Data steps can be used in conjunction with the &ldquo;where&rdquo; statement to select certain variables. For example consider the data set shown in Figure 3.5.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="402" src="images/image11.png" width="392"></p><p class="c7 c1"><span class="c8 c6">Figure 3.5 The Dwarfs data set.</span></p><p class="c1"><span class="c6">The following code selects only the elements of the above data set that start with a &ldquo;D&rdquo;.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="f455852c02a2611b5e8a7c28ee2f3df99edba2fd"></a><a href="#" name="37"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c39"><td class="c56"><p class="c1 c5"><span class="c0">data Dwarfs;</span></p><p class="c1"><span class="c0">set Dwarfs;</span></p><p class="c1"><span class="c0">where substr(Name,1,1)=&rdquo;D&rdquo;;</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1"><span class="c6">The result is shown in Figure 3.6 (note that the above code makes use of the &ldquo;substr&rdquo; function that we will in section 3.3).</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="370" src="images/image45.png" width="482"></p><p class="c7 c1"><span class="c8 c6">Figure 3.6 Elements of the Dwarfs data set starting with &ldquo;D&rdquo;.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">3.2 The program data vector</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">SAS is able to handle very large data sets because of the way data steps work. In this section we&rsquo;ll explain how it uses the &ldquo;program data vector&rdquo; (pdv) to efficiently handle data. The basic steps of compiling a data step are as follows:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c29" start="1"><li class="c4 c1"><span class="c6">SAS creates an empty data set.</span></li><li class="c4 c1"><span class="c6">SAS checks the data step for any unrecognized keywords and syntax errors.</span></li><li class="c4 c1"><span class="c6">SAS creates a PDV to store the information for all the variables required from the data step.</span></li><li class="c4 c1"><span class="c6">SAS reads in the data line by line using the PDF.</span></li></ol><p class="c1 c5 c47"><span class="c8 c6">(If a &ldquo;by&rdquo; statement is used (for example when merging two data sets) the PDF does not empty if there are still observations with the same value of the &ldquo;by&rdquo; variable).</span></p><ol class="c29" start="5"><li class="c4 c1"><span class="c6">SAS creates the descriptive portion of the SAS data set (viewable using the &ldquo;contents&rdquo; procedure).</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">An example of how this works with concatenation is shown in Figure 3.7 and an example of how this works with merging is shown in Figure 3.8.</span></p><p class="c1"><img height="384" src="images/image15.png" width="581"></p><p class="c7 c1"><span class="c8 c6">Figure 3.7 Concatenation of data sets and the pdv.</span></p><p class="c7 c1"><img height="374" src="images/image30.png" width="559"></p><p class="c7 c1"><span class="c8 c6">Figure 3.8 Merging of data sets and the pdv.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">3.3 Creating new variables</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">Creating new variables using various arithmetic and/or string relationships is relatively straightforward in SAS. The following code creates a new data set call MMM_with_BMI, with a new variable &ldquo;BMI&rdquo; as a function of the height and weight variables in the MMM dataset in the mat008 library.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="248e29fe4146aba0941c6f113bce89b34a1c1eb0"></a><a href="#" name="38"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c23"><p class="c1 c5"><span class="c0">data mat008.MMM_with_BMI;</span></p><p class="c1 c5"><span class="c0">set mat008.MMM;</span></p><p class="c1 c5"><span class="c0">bmi=weight_in_kg/(height_in_metres**2);</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1"><span class="c6">Some of the arithmetic functions are shown in Figures 3.9 and 3.10.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c6"></span></p><a href="#" name="c11613e0be08240f6e206c0dfcfed365a3992233"></a><a href="#" name="39"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr><td class="c13"><p class="c3 c1"><span class="c8 c6">Symbol</span></p></td><td class="c13"><p class="c3 c1"><span class="c8 c6">Definition</span></p></td><td class="c13"><p class="c3 c1"><span class="c8 c6">Example</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">**</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Exponential</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">y=x**3</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">*</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Multiplication</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">r=x*y</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">/</span></p></td><td class="c13"><p class="c1 c3"><span class="c6">Division</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">d=x/y</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">+</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Addition</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">s=x+y</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">-</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Subtraction</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">t=x-y</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><span class="c8 c6">Figure 3.9 Basic arithmetic operations in SAS</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c6"></span></p><a href="#" name="0a56066f7557a47aff1dab3093c3553b8b705aad"></a><a href="#" name="40"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr><td class="c13"><p class="c3 c1"><span class="c8 c6">Function</span></p></td><td class="c13"><p class="c3 c1"><span class="c8 c6">Definition</span></p></td><td class="c13"><p class="c3 c1"><span class="c8 c6">Example</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Abs</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Absolute value</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">abs(x)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Int</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Integer (takes the integer part of the argument)</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">int(x)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Log</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Natural log</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">log(x)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Log10</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Log base 10</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">log10(x)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Round</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Rounds the argument to the nearest specified level</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">round(x,.01)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Sqrt</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Square root</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">sqrt(x)</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><span class="c8 c6">Figure 3.10 Some mathematical function in SAS</span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">We can also do operations on strings, the following code replaces the variable &ldquo;Sex&rdquo; with the first entry of &ldquo;Sex&rdquo; (which gets rid of the Male - M &nbsp;and Female - F issue).</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="abf92c84286bd838417dcc5ea9a6d74c6961def3"></a><a href="#" name="41"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c62"><p class="c1 c5"><span class="c0">data mat008.MMM_with_BMI;</span></p><p class="c1 c5"><span class="c0">set mat008.MMM;</span></p><p class="c1 c5"><span class="c0">sex=substr(sex,1,1);</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">Some examples of string functions are shown in Figure 3.11.</span></p><p class="c1 c2"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c6"></span></p><a href="#" name="ff4814b0ec13131ee29d6b34d7fe989707804eb6"></a><a href="#" name="42"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr><td class="c13"><p class="c3 c1"><span class="c8 c6">Function</span></p></td><td class="c13"><p class="c3 c1"><span class="c8 c6">Definition</span></p></td><td class="c13"><p class="c3 c1"><span class="c8 c6">Example</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Substr</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Outputs a substring of length L at starting position N of a string</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">substr(string, N,L)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Upcase</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Converts a string to upper case</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">upcase(string)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Lowcase</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Converts a string to lower case</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">lowcase(string)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Trim</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Removes only trailing blanks from a string</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">trim(string)</span></p></td></tr><tr><td class="c13"><p class="c3 c1"><span class="c6">Index</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">Return 0 or a starting position of substring in given string</span></p></td><td class="c13"><p class="c3 c1"><span class="c6">index(string,substring)</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><span class="c8 c6">Figure 3.11 Some string function in SAS</span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1"><span class="c6">It&rsquo;s worth checking the web for a full list of various SAS functions (there are a huge amount of them).</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">Dropping and keeping variables.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">In this section we&rsquo;ll take a quick look at two simple ways of improving the efficiency of a data step. Recalling how SAS handles a data step (using the pdv as described in the previous section), one immediate way of improving efficiency is to ensure that the pdv only &ldquo;transports&rdquo; the variables we require. We do this with the &ldquo;drop&rdquo; or &ldquo;keep&rdquo; statement.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Let us consider the previous example and assume that &nbsp;we want our MMM_with_BMI data set without the weight and height variables. We use a &ldquo;drop&rdquo; statement to get rid of those variables:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="1a36a768319e6679c73a271594d16e0954d965ce"></a><a href="#" name="43"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c36"><p class="c1"><span class="c0">data mat008.MMM_with_BMI_nhw(drop=weight_in_kg height_in_metres);</span></p><p class="c1 c5"><span class="c0">set mat008.MMM;</span></p><p class="c1 c5"><span class="c0">bmi=weight_in_kg/(height_in_metres**2);</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c8 c6">Note that the following code </span><span class="c8 c6 c40">would not give the required output</span><span class="c8 c6">&nbsp;as we are trying to drop the variables from the original data set, however we need those variables to calculate the bmi:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="e81c2e991291020925fd630ed5a07ff38e311e68"></a><a href="#" name="44"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c10"><p class="c1"><span class="c0">data mat008.MMM_with_BMI_nhw;</span></p><p class="c1 c5"><span class="c0">set mat008.MMM(drop=weight_in_kg height_in_metres);</span></p><p class="c1 c5"><span class="c0">bmi=weight_in_kg/(height_in_metres**2);</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">The keep statement (basically) does the same thing as the drop statement but in reverse, by only keeping the variables we have specified. Which one to use depends simply on whether or not you want to drop or keep more variables.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c8 c6">Note that you cannot use a drop statement and a keep statement in the same data step.</span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">The following code will create a data set with just the bmi variable.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="0ae2c18e0a979e085fcdc31c1515aad8e8a1250d"></a><a href="#" name="45"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c10"><p class="c1"><span class="c0">data mat008.just_bmi(keep=bmi);</span></p><p class="c1 c5"><span class="c0">set mat008.MMM;</span></p><p class="c1 c5"><span class="c0">bmi=weight_in_kg/(height_in_metres**2);</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">Renaming variables</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The following code creates a data set &ldquo;JJJ&rdquo; in the work library which is a copy of the &ldquo;JJJ&rdquo; dataset in the mat008 library, renaming the &ldquo;sex&rdquo; variable to &ldquo;gender&rdquo;.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="b2b1e03a0fef97c31d774ce3e673746d7530ac65"></a><a href="#" name="46"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c33"><p class="c1"><span class="c0">data JJJ(rename=(sex=gender));</span></p><p class="c1 c5"><span class="c0">set mat008.JJJ;</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">This can also be used in the set data set:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="214778c0b0a3dc4c6157d278935da92ae63d8b54"></a><a href="#" name="47"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c20"><p class="c1"><span class="c0">data JJJ;</span></p><p class="c1 c5"><span class="c0">set mat008.JJJ(rename=(sex=gender));</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">Operations across rows</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">We have seen in previous sections how to create new variables for any given observation (i.e. across columns of a data set). In this section we see how to create variables across rows. Recalling how the program data vector works, this implies that we must find a way to keep certain entries in the pdv for future calculation.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We will demonstrate this using the birthday_money.csv data set as shown in Figure 3.12.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="211" src="images/image38.png" width="328"></p><p class="c7 c1"><span class="c8 c6">Figure 3.12 The birthday_money.csv data set.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The first such way is to use the &ldquo;retain&rdquo; statement. The &ldquo;retain&rdquo; statement keeps the last entry for a given variable in the pdv for future calculation. Note that we can give an initial value for a particular variable as shown in the following code (which produces a variable &ldquo;total&rdquo; that is a running total of &ldquo;amount&rdquo;) the output of which is shown in Figure 3.13:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="0c76d6f3698a200872e05adba99532fcbf8f1748"></a><a href="#" name="48"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c10"><p class="c1"><span class="c0">data bm_analysis;</span></p><p class="c1 c5"><span class="c0">set mat008.birthday_money;</span></p><p class="c1 c5"><span class="c0">retain total 0;</span></p><p class="c1 c5"><span class="c0">total=total+amount;</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c7 c1"><img height="298" src="images/image47.png" width="516"></p><p class="c7 c1"><span class="c6">Figure 3.13 A running total calculated using the retain statement</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Another tool for such calculations is the &ldquo;lag</span><span class="c22 c6">n</span><span class="c6">&rdquo; function which gives the value of a variable from a certain number </span><span class="c22 c6">n </span><span class="c6">of prior steps. The following code gives two new variables, the yearly difference and 2 yearly difference, the result of which is shown in Figure 3.14.</span></p><p class="c1"><span class="c8 c6">&nbsp;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="4ac19bc9bf7e3d788d842830555b697b4cf30a62"></a><a href="#" name="49"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c64"><p class="c1"><span class="c0">data bm_analysis;</span></p><p class="c1 c5"><span class="c0">set mat008.birthday_money;</span></p><p class="c1 c5"><span class="c0">retain total 0;</span></p><p class="c1 c5"><span class="c0">total=total+amount;</span></p><p class="c1 c5"><span class="c0">yearly_diff=amount-lag1(amount);</span></p><p class="c1 c5"><span class="c0">two_yearly_diff=amount-lag2(amount);</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c7 c1"><img height="219" src="images/image40.png" width="617"></p><p class="c7 c1"><span class="c8 c6">Figure 3.14 Yearly and 2 yearly differences calculated using the lag1 and lag2 functions.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">The lag functions can be used in much more complex assignments and in fact when simply wanting to calculate a difference there is a quicker way: using the &ldquo;dif</span><span class="c22 c6">n</span><span class="c6">&rdquo;</span><span class="c6 c22">&nbsp;</span><span class="c6">function as shown in the code below which gives the same result as shown in Figure 3.14.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="19387ae76b5145fc40aa7237ae820a9c5ff64831"></a><a href="#" name="50"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c10"><p class="c1"><span class="c0">data bm_analysis;</span></p><p class="c1 c5"><span class="c0">set mat008.birthday_money;</span></p><p class="c1 c5"><span class="c0">retain total 0;</span></p><p class="c1 c5"><span class="c0">total=total+amount;</span></p><p class="c1 c5"><span class="c0">yearly_diff=dif1(amount);</span></p><p class="c1 c5"><span class="c0">two_yearly_diff=dif2(amount);</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">3.4 Handling dates</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">Dates are handled in a particular way in SAS. Let&rsquo;s consider the csv shown in Figure 3.15.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="517" src="images/image37.png" width="283"></p><p class="c7 c1"><span class="c8 c6">Figure 3.15 The birthdays csv file.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">We have seen in Chapter 1 how to import data using proc import. If we use the normal approach an error would occur. This is due to the confusion associated with our birthday variables (the first 20 rows have the date and month values both less than 12). A further option that can be incorporated in proc import is the number of rows that SAS will &ldquo;pre-read&rdquo; to identify the type of variables that are to be imported. This is often an easy way to ensure that SAS recognises dates. </span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="8e40fc98a109d9cc7e2c75918eb766cfca8eea6f"></a><a href="#" name="51"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c68"><p class="c1"><span class="c0">proc import datafile=&rsquo;~birthdays.csv&rsquo;</span></p><p class="c1"><span class="c0">out=birthdays</span></p><p class="c1"><span class="c0">replace;</span></p><p class="c1"><span class="c0">getnames=yes;</span></p><p class="c1"><span class="c0">guessingrows=25;</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">A proc contents (shown in Figure 3.16) run on the above data set shows that the birthday variable data was imported using the informat DDMMYY10. In other words SAS has recognised that the dates were in that particular format.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="348" src="images/image50.png" width="512"></p><p class="c7 c1"><span class="c8 c6">Figure 3.16 Proc contents on the birthdays file.</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Another approach is to import files in SAS using a data step and the infile statement. When doing this we can tell SAS the format of the data (whether or not it is a string, numerical or date variables).</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="8aaa187e85c45845f1d87a6c9be4d259ac9523a1"></a><a href="#" name="52"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c58"><p class="c1 c5"><span class="c0">data birthdays;</span></p><p class="c1 c5"><span class="c0">infile &lsquo;~/birthdays.csv&rsquo; dlm=&rsquo;,&rsquo; firstobs=2;</span></p><p class="c1 c5"><span class="c0">input &nbsp;Name $ Birthday ddmmyy10.;</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The infile statement tells SAS where the data is located and the &lsquo;dlm&rsquo; statement tells SAS how the file is delimited (in this case with a comma). The &lsquo;firstobs&rsquo; statement tells SAS where the data starts in the file (in this case the second row as the first row is the name of the variables in our data set). The input statement then allows us to tell SAS the names of the variables as well as the format they are in, here we tell SAS that the second variable is to be called &lsquo;Birthday&rsquo; and it is in the ddmmyy8. format. The data is shown in Figure 3.17.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="485" src="images/image63.png" width="309"></p><p class="c7 c1"><span class="c8 c6">Figure 3.17 The birthdays data set import using the infile statement.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The above output might be a bit confusing, this is due to the fact that SAS handles dates as numbers, using the convention that the 1st of January 1960 is the number 0 (this allows for straightforward arithmetic manipulation of dates). The following code imports the data as above and displays the underlying numeric dates in the date9. format.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="b1618887d0b93effcb912cbc57310220a94ba6d6"></a><a href="#" name="53"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c38"><p class="c1 c5"><span class="c0">data birthdays;</span></p><p class="c1 c5"><span class="c0">infile &lsquo;~/birthdays.csv&rsquo; dlm=&rsquo;,&rsquo; firstobs=2;</span></p><p class="c1 c5"><span class="c0">input &nbsp;Name $ Birthday ddmmyy8.;</span></p><p class="c1 c5"><span class="c0">format Birthday date9.;</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1"><span class="c6">The output is shown in Figure 3.18. Note that applying the date9. format </span><span class="c8 c6">only</span><span class="c6">&nbsp;changes the appearance of the data.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="511" src="images/image51.png" width="330"></p><p class="c7 c1"><span class="c8 c6">Figure 3.18 The birthdays data set import using the infile statement.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">There are various formats that can be used when importing variables (for dates as well as other variables) and subsequently these same formats can be used to display the data if this is required. Searching online quickly finds other SAS formats.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c1"><span class="c8 c6"></span></p><p class="c2 c7 c1"><span class="c37 c8"></span></p><p class="c7 c1"><span class="c37 c8">Chapter 4 Programming</span></p><hr style="page-break-before:always;display:none;"><p class="c2 c7 c1"><span class="c37 c8"></span></p><p class="c1"><span class="c8 c6">4.1 Flow control</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">A huge part of programming (in any language) is the use of so called &ldquo;conditional statements&rdquo;. We do this in SAS using &ldquo;if&rdquo; statements. The following code creates a new variable &ldquo;age_group&rdquo; which is &ldquo;young&rdquo; if the age is less than 29 and &ldquo;old&rdquo; if the age is larger than 29. Note we&rsquo;re also including a keep statement to just have the name and age_group in the new data set.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="4317d719a125686b10013c5e9a6153d6bd532abe"></a><a href="#" name="54"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c10"><p class="c1"><span class="c0">data age_group(keep= name age_group);</span></p><p class="c1 c5"><span class="c0">set mat008.mmmjjj;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">if age&lt;30 then age_group=&rsquo;young&rsquo;;</span></p><p class="c1 c5"><span class="c0">&nbsp; else age_group=&rsquo;old&rsquo;;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">We can also use this in conjunction with the else if statement as shown below:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="2a897e140fb617683d04bc57bcf12d245626832d"></a><a href="#" name="55"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c10"><p class="c1"><span class="c0">data age_group(keep= name age_group);</span></p><p class="c1 c5"><span class="c0">set mat008.mmmjjj;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">if age&lt;18 then age_group=&rsquo;child&rsquo;;</span></p><p class="c1 c5"><span class="c0">&nbsp; else if age&lt;30 then age_group=&rsquo;young&rsquo;;</span></p><p class="c1 c5"><span class="c0">&nbsp; &nbsp; else age_group=&rsquo;old&rsquo;;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1"><span class="c6">Note that we can also compare strings as shown with the following code:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="60955c32cf8985ebc5b502ad9791e11a5d501f5b"></a><a href="#" name="56"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c10"><p class="c1"><span class="c0">data age_group(keep= name age_group);</span></p><p class="c1 c5"><span class="c0">set mat008.mmmjjj;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">if age&lt;18 then age_group=&rsquo;child&rsquo;;</span></p><p class="c1 c5"><span class="c0">&nbsp; else if age&lt;30 then age_group=&rsquo;young&rsquo;;</span></p><p class="c1 c5"><span class="c0">&nbsp; &nbsp; else age_group=&rsquo;old&rsquo;;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">if </span><span class="c0">substr(Name,1,1)</span><span class="c0">=&rsquo;J &lsquo; then data_set=&lsquo;JJJ&rsquo;;</span></p><p class="c1 c5"><span class="c0">&nbsp; else data_set=&rsquo;MMM&rsquo;;</span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Figure 4.1 shows some of the comparison operators that can be used in conjunction with &lsquo;if&rsquo; statements.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="230" src="images/image29.png" width="637"></p><p class="c7 c1"><span class="c8 c6">Figure 4.1 SAS Comparison Operators.</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">A further important notion in programming is the notion of loops. These are done in SAS using &ldquo;do&rdquo; statements. There are four ways the &ldquo;do&rdquo; statement is used:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">do</span></li><li class="c4 c1"><span class="c6">do (iterative)</span></li><li class="c4 c1"><span class="c6">do while</span></li><li class="c4 c1"><span class="c6">do until</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1"><span class="c6">The first use allows us to combine several statement into one. This is often used in conjunction with &ldquo;if&rdquo; statements:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="4b2b403955a1230c6820528d348a230c5328cee0"></a><a href="#" name="57"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c55"><p class="c1"><span class="c0">data age_group(keep= name age_group minor_Y_N);</span></p><p class="c1 c5"><span class="c0">set mat008.mmmjjj;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">if age&lt;18 then do;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">age_group=&rsquo;Child&rsquo;;</span></p><p class="c1 c5"><span class="c0">minor_Y_N=&rsquo;Y&rsquo;;</span></p><p class="c1 c5"><span class="c0">end;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">else do;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">age_group=&rsquo;Adult&rsquo;;</span></p><p class="c1 c5"><span class="c0">minor_Y_N=&rsquo;N&rsquo;;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">end;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The &lsquo;do&rsquo; statement can be used to push your computer a bit more. The &ldquo;do iterative statement&rdquo; allows you to automate various procedures. The following code output the total number of birthday candles that would have been used on everyones birthday cake in the JJJ data set.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="34e4bdc48e16bc37aa4b9f850d9e8a240fc74d21"></a><a href="#" name="58"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c10"><p class="c1"><span class="c0">data candles(keep= name age candles);</span></p><p class="c1 c5"><span class="c0">set mat008.jjj;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">candle=0;</span></p><p class="c1 c5"><span class="c0">do k=0 to age;</span></p><p class="c1 c5"><span class="c0">candle=candle+k;</span></p><p class="c1 c5"><span class="c0">end;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The last two uses of the &lsquo;do&rsquo; statement are very similar and allow us to iterate &ldquo;until/while&rdquo; a particular condition is met. </span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The do until (expression) statement executes a group of statements until the expression within the brackets is satisfied. The validity of the expression is checked at the end of each loop.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="b58a2d40a6c20d870823e8334b0e1a668ce7842e"></a><a href="#" name="59"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c19"><p class="c1"><span class="c0">do until (expression);</span></p><p class="c1"><span class="c0">data step commands;</span></p><p class="c1"><span class="c0">end;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The following code outputs the number of even numbers less than or equal to 70, computing each even number and checking whether or not it&rsquo;s more than 70.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="f7bc9c091f38d3dee6db069380a945548596a504"></a><a href="#" name="60"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c19"><p class="c1"><span class="c0">data even_numbers;</span></p><p class="c1"><span class="c0">k=0;</span></p><p class="c1"><span class="c0">even=0;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">do until(even&gt;=70);</span></p><p class="c1"><span class="c0">even=2*k;</span></p><p class="c1"><span class="c0">k=k+1;</span></p><p class="c1 c5"><span class="c0">end;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We can do a similar calculation using the do &ldquo;while&rdquo; statement. The do while (expression) statement executes a group of statements whilst the expression within the brackets is satisfied. The validity of the expression is checked at the beginning of each loop.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="a14cbfacad0ab5e86b9eb9ef7af8b5fdf2715ce3"></a><a href="#" name="61"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c19"><p class="c1"><span class="c0">do &nbsp;while (expression);</span></p><p class="c1"><span class="c0">data step commands;</span></p><p class="c1 c5"><span class="c0">end;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="955c0b2ff5a6f29e60191ed1e277633910fa57a8"></a><a href="#" name="62"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c19"><p class="c1"><span class="c0">data even_numbers;</span></p><p class="c1"><span class="c0">k=0;</span></p><p class="c1"><span class="c0">even=0;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">do while(even&lt;70);</span></p><p class="c1"><span class="c0">even=2*k;</span></p><p class="c1"><span class="c0">k=k+1;</span></p><p class="c1 c5"><span class="c0">end;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c8 c6">Note</span><span class="c6">&nbsp;that do iterative statements (also called &ldquo;do loops&rdquo;) are often used in conjunction with the &ldquo;output&rdquo; statement which empties the pdv to the output data set. The following code outputs the variables in the pdv: &ldquo;k&rdquo; and &ldquo;even&rdquo; at each iteration of the do statement. The output is shown in Figure 4.2.</span></p><p class="c2 c1 c5"><span class="c0"></span></p><a href="#" name="ae27ad828d72e922558009fa15f1abcc7be703be"></a><a href="#" name="63"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c19"><p class="c1"><span class="c0">data even_numbers;</span></p><p class="c1"><span class="c0">k=0;</span></p><p class="c1"><span class="c0">even=0;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">do while(even&lt;70);</span></p><p class="c1"><span class="c0">even=2*k;</span></p><p class="c1"><span class="c0">output;</span></p><p class="c1"><span class="c0">k=k+1;</span></p><p class="c1 c5"><span class="c0">end;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="517" src="images/image18.png" width="319"></p><p class="c7 c1"><span class="c8 c6">Figure 3.2 The first even numbers less than 70.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">4.2 How does SAS compile code?</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">In this chapter we will see how to program macros in SAS. Macros generate and run code with varying arguments. The macro facility is a tool for extending and customising SAS and for reducing the amount of text you must enter to do common tasks. The macro facility enables you to assign a name to character strings or groups of SAS programming statements. From that point on, you can work with the names rather than with the text itself.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">When you submit a SAS macro the </span><span class="c8 c6">Input stack</span><span class="c6">&nbsp;receives content of the program. Word scanner scans each line of the macro for </span><span class="c8 c6">tokens</span><span class="c6">. If a </span><span class="c8 c6">token</span><span class="c6">&nbsp;contains a macro character (a </span><span class="c8 c6">%</span><span class="c6">&nbsp;or a </span><span class="c8 c6">&amp;</span><span class="c6">) that token is sent to the macro compiler. The Macro compiler does its work and places tokens back in the input stack. The token is examined by the word scanner and the process repeats. When the word scanner detects a step boundary it triggers the data step compiler. This process is represented diagrammatically in Figure 4.1.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="403" src="images/image48.png" width="601"></p><p class="c7 c1"><span class="c8 c6">Figure 4.2 How SAS compiles code.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1"><span class="c6">When you submit a macro, it goes first to the macro processor which produces standard SAS code from the macro references (macro code is compiled first). Then SAS compiles and executes your program.</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">In general the syntax for a macro is as follows:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="abddc05963f14c195e23bf0ee23547cf4bff6338"></a><a href="#" name="64"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c24"><p class="c1"><span class="c0">%macro macro-name &lt;(macro-parameter-list&gt;;</span></p><p class="c1"><span class="c0">&hellip; SAS Code...</span></p><p class="c1"><span class="c0">%mend &lt;macro-name&gt;</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">The following example creates a macro called &ldquo;My_plot&rdquo; which when called will plot a graph of height against weight of the variables in mat008.jjj:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="1ea5cd8f86e2cf0ad234468d2acc97f282723ae8"></a><a href="#" name="65"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c24"><p class="c1"><span class="c0">%macro My_plot;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">proc gplot data=mat008.jjj;</span></p><p class="c1"><span class="c0">plot height_in_metres*weight_in_kg;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">To run the macro we call it with the following statement:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="78ce39732f3124cc75aa7e793429cb972e9c247b"></a><a href="#" name="66"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c24"><p class="c1"><span class="c0">%My_plot;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Note that it&rsquo;s very important to always remember the diagram of Figure 4.1 when working through this chapter (if you do it will all make sense). </span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">As discussed above, it is possible to pass arguments to a macro. The following code creates a macro &ldquo;shopping&rdquo; that will remove a certain quantity &ldquo;spend&rdquo; from the variable &ldquo;life_savings&rdquo;:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="4e6a5b2b6a967e31f0c7695dffb1d4f899383d36"></a><a href="#" name="67"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c48"><p class="c1"><span class="c0">%macro shopping(spend);</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">data JJJ_after_shopping(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">Old_savings=savings_in_pounds;</span></p><p class="c1"><span class="c0">New_savings=saving_in_pounds-&amp;spend;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Note (recall Figure 4.2) the ampersand &ldquo;&amp;&rdquo; which the &ldquo;word scanner&rdquo; will recognise, sending &ldquo;&amp;spend&rdquo; to the &ldquo;macro compiler&rdquo; where it will resolve to whatever value is passed to the macro.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We can define macros with multiple variables. Consider the following modification of the above code which allows for multiple shopping trips:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="ef71fde175ff125919321ffb98bef3270532a27b"></a><a href="#" name="68"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c67"><p class="c1"><span class="c0">%macro shopping(spend,trips);</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">data JJJ_after_shopping(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">Old_savings=savings_in_pounds;</span></p><p class="c1"><span class="c0">New_savings=saving_in_pounds-&amp;trips*&amp;spend;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The above code is using so called &ldquo;positional&rdquo; macro parameters. It is possible to also use &ldquo;keyword&rdquo; macro parameters as shown in the code below.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="f652fe1f047c58cc14d6ad8d82b5aeb0f77d6c5c"></a><a href="#" name="69"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c49"><p class="c1"><span class="c0">%macro shopping(spend=,trips=);</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">data JJJ_after_shopping(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">Old_savings=savings_in_pounds;</span></p><p class="c1"><span class="c0">New_savings=saving_in_pounds-&amp;trips*&amp;spend;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We can then call the above macro and change the order of the parameters:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="42084b662d7b30252959a38723392e69b38084f6"></a><a href="#" name="70"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c33"><p class="c1"><span class="c0">%shopping(trips=2,spend=500);</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">It&rsquo;s also possible to set default values:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="489056ac84b7d04fc380564ea9a556e5dca2567d"></a><a href="#" name="71"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c46"><p class="c1"><span class="c0">%macro shopping(spend=,trips=1);</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">data JJJ_after_shopping(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">Old_savings=savings_in_pounds;</span></p><p class="c1"><span class="c0">New_savings=saving_in_pounds-&amp;trips*&amp;spend;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">Now </span><span class="c8 c6">if </span><span class="c6">we call the macro </span><span class="c8 c6">without</span><span class="c6">&nbsp;giving a value to trips it will take the default value 1. </span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="024ca08a48b970dd9770928e336593fe797709ad"></a><a href="#" name="72"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c59"><p class="c1"><span class="c0">%shopping(spend=500);</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c8 c6">Macro variables</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">In this section we&rsquo;re going to take a slightly closer look at macro variables. A macro variable is a variable whose value is stored within the </span><span class="c8 c6">macro symbol table</span><span class="c6">. When the macro variable is used in SAS code, SAS substitutes the value of the macro variable into the SAS code. SAS macro variables are distinguished by the &ldquo;&amp;&rdquo; sign before the variable name. Note that all SAS macro variables are stored as text strings.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We can experiment with macro variables using the %let statement which allows the construction of macro variables outside of a macro definition. This is the simplest form of a macro statement. It can be placed anywhere in a program, not only inside a Macro. &ldquo;</span><span class="c8 c6">%let&rdquo; creates global macro variables</span><span class="c6">. An example of this is shown in the following code which gives the output of Figure 4.3:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="53f92fec6348ce904774cdbf8db8288b22d450d8"></a><a href="#" name="73"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c1 c5"><span class="c0">%let spend=400;</span></p><p class="c1 c5"><span class="c0">%let trips=500;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1"><span class="c0">%macro shopping;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">data JJJ_after_shopping(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">Old_savings=savings_in_pounds;</span></p><p class="c1"><span class="c0">New_savings=saving_in_pounds-&amp;trips*&amp;spend;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%mend</span><span>;</span></p><p class="c2 c1 c5"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%shopping;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c7 c1"><img height="323" src="images/image52.png" width="585"></p><p class="c7 c1"><span class="c8 c6">Figure 4.3 Output of a macro using the %let statement.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">It&rsquo;s also possible to view (in the log) the values of a macro variable using the &ldquo;%put&rdquo; statement. There are two uses for it:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="e4258858587e1a20334848056c832946ddbe6c94"></a><a href="#" name="74"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c57"><p class="c1 c5"><span class="c0">%put &lt;text&gt; &amp;macro-variable-name;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">This outputs some &lt;text&gt; (optional) followed by the value of particular macro variable. The other use is shown below:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="214cf09219090ef18e9688eeffecb60945801be5"></a><a href="#" name="75"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c42"><p class="c1 c5"><span class="c0">%put &nbsp;&lt;_all_ | _global_ | _local_ &gt;;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">This will output either all, all the global or all the local macro variables. These statements should allow us to better understand some of the issues related to the resolution of multiple ampersands. Multiple ampersands can be used to allow the value of a macro variable to become another macro variable reference. The macro variable reference will be rescanned until the macro variable is resolved. There are 2 rules to follow:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">&amp;&amp; is a token in its own right and resolves to &amp;</span></li><li class="c4 c1"><span class="c6">Each token is handled independently</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Look through Figures 4.4a and 4.4b </span><span class="c8 c6">but importantly keep Figure 4.2 in mind. </span><span class="c6">The important thing to note here is that a </span><span class="c8 c6">double ampersand</span><span class="c6">&nbsp;&ldquo;&amp;&amp;&rdquo; is a </span><span class="c8 c6">token </span><span class="c6">in itself that resolves to a single ampersand &ldquo;&amp;&rdquo; </span><span class="c8 c6">(THIS IS IMPORTANT)</span><span class="c6">.</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c7 c1"><img height="348" src="images/image44.png" width="525"></p><p class="c7 c1"><span class="c8 c6">Figure 4.4a Understanding multiple ampersands</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c7 c1"><img height="391" src="images/image43.png" width="523"></p><p class="c7 c1"><span class="c8 c6">Figure 4.4b Understanding multiple ampersands</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c8 c6">4.3 &nbsp;SAS Macro programming statements</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The &lsquo;if&rsquo; statements and &lsquo;do&rsquo; loops of section 3 work in a very similar way to if statements and do loops within macros. The only modification is that these can be evaluated within the macro compiler before the entire submitted code is resolved. For this to work we need to use the &ldquo;%if&rdquo;, &ldquo;%then&rdquo; and &ldquo;%else&rdquo; statements when evaluating a conditional statement on a macro variable. The following code is an example of this:</span></p><p class="c2 c1"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="e390a1d36450a2a08bfc039e2ad217ad868bba69"></a><a href="#" name="76"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c1"><span class="c0">%macro shopping(spend,trips);</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">data JJJ_after_shopping(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">%if &amp;spend&lt;0 %then %put Carefull the spend is negative!;</span></p><p class="c1"><span class="c0">%else %put The spend is positive;</span></p><p class="c1"><span class="c0">Old_savings=savings_in_pounds;</span></p><p class="c1"><span class="c0">New_savings=savings_in_pounds-&amp;trips*&amp;spend;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The &ldquo;%do&rdquo; statement can be used in conjunction with &ldquo;%if&rdquo; statements. The following code creates one of two data sets depending on the sign of the macro variable spend.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="fa06af8099e86ec3451a85d7da5449a3e18bf6b1"></a><a href="#" name="77"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c25"><p class="c1"><span class="c0">%macro shopping(spend,trips);</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">%if &amp;spend&lt;0 %then %do;</span></p><p class="c1"><span class="c0">data JJJ_after_saving(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">%end;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">%else %do;</span></p><p class="c1"><span class="c0">data JJJ_after_spending(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">%end;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">Old_savings=savings_in_pounds;</span></p><p class="c1"><span class="c0">New_savings=savings_in_pounds-&amp;trips*&amp;spend;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Another use of the %do statement is in iterative statements (as before). The difference being that on this occasion the %do statement </span><span class="c8 c6">creates </span><span class="c6">macro variables. The following code creates various data sets each with a title indexed by a macro variable.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="6e9eb301585ccd5e64d061d51fbcfcb6e3d53e5b"></a><a href="#" name="78"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c25"><p class="c1"><span class="c0">%macro shopping(spend);</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">%do trips=1 %to 10;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">data JJJ_after_saving_&amp;trips(keep= Name Old_savings New_savings);</span></p><p class="c1"><span class="c0">set mat008.jjj;</span></p><p class="c1"><span class="c0">Old_savings=savings_in_pounds;</span></p><p class="c1"><span class="c0">New_savings=savings_in_pounds-&amp;trips*&amp;spend;</span></p><p class="c1"><span class="c0">run;</span></p><p class="c1"><span class="c0">%end;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The %do statement can also be used in conjunction with the %while and %until statements.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The way SAS compiles macro code can be an extremely useful tool. For example the following code creates a macro that imports 5 separate csv file:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="7f5bd0e82d3b3c608f0faa75131b0ed681ee5ec9"></a><a href="#" name="79"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c14"><td class="c48"><p class="c1"><span class="c0">%macro import;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1"><span class="c0">%do i=1 %to 5;</span></p><p class="c1"><span class="c0">proc import datafile=&quot;~/File_&amp;i.csv&quot;<br> &nbsp; &nbsp; out=File_&amp;i<br> &nbsp; &nbsp; dbms=csv<br> &nbsp; &nbsp; replace;<br> &nbsp; &nbsp; getnames=yes;<br>run;</span></p><p class="c1"><span class="c0">%end;</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c1 c5"><span class="c0">%mend</span><span>;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The output is shown in Figure 4.5.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="303" src="images/image04.png" width="408"></p><p class="c7 c1"><span class="c8 c6">Figure 4.5 Importing multiple data sets using macros.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c8 c6">4.4 Macro functions</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">Since all macro variables are text strings it is not possible to directly perform computations on macro variables that contain numbers. The following code would give an error:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="271d36efbeda86af12617808712c6c0844fb0196"></a><a href="#" name="80"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c44"><p class="c1"><span class="c0">%let var=5**2;</span></p><p class="c1"><span class="c0">%put &amp;var;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">One must make use of the following function to be able to evaluate (in the macro compiler) such computations:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="6c4a77f1a166e582624190034d1e6f7015f00dd6"></a><a href="#" name="81"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c28"><p class="c1"><span class="c0">%let var=5**2;</span></p><p class="c1 c5"><span class="c0">%put %eval(&amp;var);</span></p><p class="c1 c5"><span class="c0">%put %sysevalf(&amp;var);</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The &ldquo;%sysevalf&rdquo; function works in a very similar way to the &ldquo;%eval&rdquo; but will compute fractions such as 9/2 in the Real numbers (as opposed to eval which would round the result). </span></p><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">Another use of macro functions is when it comes to </span><span class="c22 c6">ignoring</span><span class="c6">&nbsp;certain SAS keywords. The following code puts two different statements to the log.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="72434eed44382df749592a0e6b84848b3bd5d22b"></a><a href="#" name="82"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c61"><p class="c1"><span class="c0">%let myvar=abc;</span></p><p class="c1 c5"><span class="c0">%put %str(this string is; &amp;myvar);</span></p><p class="c1"><span class="c0">%put %nrstr(this string is; &amp;myvar %let);</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The first macro function &ldquo;%str&rdquo; ignores the &ldquo;;&rdquo; and treats it as a string. The second macro function &ldquo;nrstr&rdquo; ignores all the SAS statements including &ldquo;;,&amp;&rdquo; and &ldquo;%&rdquo;.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">There are a large number of macro functions and it&rsquo;s worth looking around if you think there&rsquo;s one you might need. Also, of interest are the following commands (look them up) that can help with debugging:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">mprint</span></li></ol><ol class="c34" start="1"><li class="c15 c1 c5"><span class="c6">writes all non-macro code generated by the macro</span></li></ol><ol class="c17" start="2"><li class="c4 c1"><span class="c6">mlogic</span></li></ol><ol class="c34" start="1"><li class="c1 c5 c15"><span class="c6">when a macro begins executing</span></li><li class="c15 c1 c5"><span class="c6">values of macro parameters</span></li><li class="c15 c1 c5"><span class="c6">when program statements execute</span></li><li class="c15 c1 c5"><span class="c6">the status of any %if or %do condition</span></li><li class="c15 c1 c5"><span class="c6">when a macro stops executing</span></li></ol><ol class="c17" start="3"><li class="c4 c1"><span class="c6">Symbolgen</span></li></ol><ol class="c34" start="1"><li class="c15 c1 c5"><span class="c6">writes information concerning the resolution of macro variables to the log</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c37 c8"><br></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c7 c1"><span class="c37 c8"></span></p><p class="c7 c1"><span class="c37 c8">Chapter 5 SAS SQL</span></p><hr style="page-break-before:always;display:none;"><p class="c2 c7 c1"><span class="c37 c8"></span></p><p class="c1"><span class="c8 c6">5.1 Basic SQL</span></p><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">SQL is a language designed for querying and modifying databases. Used by a variety of database management software suites:</span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">Oracle</span></li><li class="c4 c1"><span class="c6">Microsoft ACCESS</span></li><li class="c4 c1"><span class="c6">SPSS</span></li></ol><p class="c1 c5"><span class="c6">SQL uses one or more objects called TABLES where: rows contain records (observations) and columns contain variables. &nbsp;Importantly, </span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c1 c4"><span class="c6">Starts with proc sql; (as expected)</span></li><li class="c4 c1"><span class="c6">Ends with quit; (some interactive procedures do)</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The following code creates a data set called test in the work library as a copy of the mat008.mmm data set:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="255f752e277f62901ef3e5f6c6aceba2669531d0"></a><a href="#" name="83"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c54"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table test as</span></p><p class="c1"><span class="c0">select *</span></p><p class="c1"><span class="c0">from mat008.mmm;</span></p><p class="c1"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">The &ldquo;*&rdquo; command tells SAS to take all variables from mat008.mmm. We can however specify exactly what variables we want:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="feb4200c1e17755236dd809cc869c70237794875"></a><a href="#" name="84"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c35"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table test as</span></p><p class="c1"><span class="c0">select Name, Age, Sex</span></p><p class="c1"><span class="c0">from mat008.mmm;</span></p><p class="c1 c5"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c6"></span></p><p class="c1"><span class="c6">We can also create new variables:</span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="2969e77d12946e827a3a88f7f4786ef69f36c650"></a><a href="#" name="85"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table test as</span></p><p class="c1"><span class="c0">select Name, Age, Sex, weight_in_kg/(height_in_metres**2) as bmi</span></p><p class="c1"><span class="c0">from mat008.mmm;</span></p><p class="c1"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c8 c6">5.2 Further SQL</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">In this section we&rsquo;ll take a look at what else SAS can do. For the purpose of the following examples let&rsquo;s write a new data set:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="e03f7fa42daa92b983361679d4f9b63de54abc41"></a><a href="#" name="86"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">data mat008.example;</span></p><p class="c1"><span class="c0">input Var1 $ Var2 Var3 $ Var 4 Var5 $;</span></p><p class="c1"><span class="c0">cards;</span></p><p class="c1"><span class="c0">A 1 A 2 B</span></p><p class="c1"><span class="c0">A 1 A 2 B</span></p><p class="c1"><span class="c0">B 1 A 1 C</span></p><p class="c1"><span class="c0">C 2 B 2 D</span></p><p class="c1"><span class="c0">C 2 C 1 E</span></p><p class="c1"><span class="c0">;</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">Some simple SQL code very easily helps us to get rid of duplicate rows (this can be very helpful when handling real data). To do this we use the &ldquo;distinct&rdquo; keyword.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="32f78d612248f5e02a6369aa707468043dbf2fca"></a><a href="#" name="87"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table example as</span></p><p class="c1"><span class="c0">select distinct * </span></p><p class="c1"><span class="c0">from mat008.example;</span></p><p class="c1 c5"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c1 c5"><span class="c6">We can also select particular variables:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="fe9d37aac643fbd526e7bcb4f70dce37cfea3ea2"></a><a href="#" name="88"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table example as</span></p><p class="c1"><span class="c0">select distinct var1, var2, var3</span></p><p class="c1"><span class="c0">from mat008.example;</span></p><p class="c1 c5"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We can also use the &ldquo;where&rdquo; statement to select variables that obey a particular condition:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="bcd6e173ca3f92b57ed5cd92b65fc9df34987f38"></a><a href="#" name="89"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table example as</span></p><p class="c1"><span class="c0">select * </span></p><p class="c1"><span class="c0">from mat008.example</span></p><p class="c1 c5"><span class="c0">where var2&lt;=var4;</span></p><p class="c1 c5"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We can sort data sets using the &ldquo;order by&rdquo; keyword:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="effcee70a03516305503bf89fd8acf36ee68feca"></a><a href="#" name="90"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table example as</span></p><p class="c1"><span class="c0">select distinct * </span></p><p class="c1"><span class="c0">from mat008.example</span></p><p class="c1"><span class="c0">order by var1;</span></p><p class="c1 c5"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">A very nice application of SQL is in the aggregation of summary statistics. The following code creates a new variable that gives the average value of var2. The value of this variable is the same for all the observations:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="2a92f38a98d060686ecfb9087e2b8c6ba44fd284"></a><a href="#" name="91"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table example as</span></p><p class="c1"><span class="c0">select *, mean(var2) as average_of_var2 </span></p><p class="c1"><span class="c0">from mat008.example;</span></p><p class="c1 c5"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">We could however get something a bit more useful by aggregating the data using a &ldquo;group&rdquo; statement:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="31f63d0abbad677ba87c39f39d29fcb2b8be99be"></a><a href="#" name="92"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table example as</span></p><p class="c1"><span class="c0">select var1, mean(var2) as average_of_var2 </span></p><p class="c1"><span class="c0">from mat008.example</span></p><p class="c1"><span class="c0">group by var1;</span></p><p class="c1 c5"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c8 c6">5.3 Joining tables with SQL</span></p><p class="c2 c1 c5"><span class="c8 c6"></span></p><p class="c1 c5"><span class="c6">A very common use of SQL within SAS is to carry out &ldquo;joins&rdquo; which are equivalent to a merger of data sets. There are 4 types of joins to consider:</span></p><p class="c2 c1 c5"><span class="c6"></span></p><ol class="c17" start="1"><li class="c4 c1"><span class="c6">inner join</span></li></ol><ol class="c34" start="1"><li class="c15 c1 c5"><span class="c6">output table only contains rows common to all tables</span></li><li class="c15 c1 c5"><span class="c6">variable attributes taken from left most table</span></li></ol><ol class="c17" start="2"><li class="c4 c1"><span class="c6">outer join left</span></li></ol><ol class="c34" start="1"><li class="c15 c1 c5"><span class="c6">output table contains all rows contributed by the left table</span></li><li class="c15 c1 c5"><span class="c6">variable attributes taken from left most table</span></li></ol><ol class="c17" start="3"><li class="c4 c1"><span class="c6">outer join right</span></li></ol><ol class="c34" start="1"><li class="c15 c1 c5"><span class="c6">output table contains all rows contributed by the right table</span></li><li class="c15 c1 c5"><span class="c6">variable attributes taken from right most table</span></li></ol><ol class="c17" start="4"><li class="c4 c1"><span class="c6">outer join full</span></li></ol><ol class="c34" start="1"><li class="c15 c1 c5"><span class="c6">output table contains all rows contributed by all tables</span></li><li class="c15 c1 c5"><span class="c6">variable attributes taken from left most table</span></li></ol><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">To work with these examples let&rsquo;s use the data sets created with the following code:</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="49b8bace78784f3b124b2bc04d5c355fc41ca1cb"></a><a href="#" name="93"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">data mat008.dogs;</span></p><p class="c1"><span class="c0">input Owner $ Name $;</span></p><p class="c1"><span class="c0">cards;</span></p><p class="c1"><span class="c0">Jeff Ruffus</span></p><p class="c1"><span class="c0">Janet Sam</span></p><p class="c1"><span class="c0">Paul .</span></p><p class="c1"><span class="c0">Joanna .</span></p><p class="c1"><span class="c0">;</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="565f7977458dbc325c7ad95cdae740807e98ad25"></a><a href="#" name="94"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c18"><p class="c1"><span class="c0">data mat008.cats;</span></p><p class="c1"><span class="c0">input Owner $ Name $;</span></p><p class="c1"><span class="c0">cards;</span></p><p class="c1"><span class="c0">Jeff Kitty</span></p><p class="c1"><span class="c0">Paul .</span></p><p class="c1"><span class="c0">Joanna Tinkerbell</span></p><p class="c1"><span class="c0">Vince Chick</span></p><p class="c1"><span class="c0">;</span></p><p class="c1 c5"><span class="c0">run;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c1 c5"><span class="c6">The following code carries out an inner join of these two datasets also changing the name of the &ldquo;Name&rdquo; variable depending on which data set it was from, the output of which is shown in Figure 5.1.</span></p><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="89aee80361eeeef9e065083eea1e76480042ff01"></a><a href="#" name="95"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c65"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table merged_table as</span></p><p class="c1"><span class="c0">select a.Owner,a.Name as Dog_Name, b.Name as cat_Name</span></p><p class="c1"><span class="c0">from mat008.dogs as a, mat008.cats as b</span></p><p class="c1"><span class="c0">where a.Owner=b.Owner;</span></p><p class="c1 c5"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="254" src="images/image23.png" width="468"></p><p class="c7 c1"><span class="c8 c6">Figure 5.1 The output of an inner join.</span></p><p class="c2 c7 c1"><span class="c8 c6"></span></p><p class="c1"><span class="c6">The following code carries out a left outer join, the output of which is shown in Figure 5.2.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="6fadc32c20065296072b2c6c96d2f7e5fa735467"></a><a href="#" name="96"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c11"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table merged_table as</span></p><p class="c1"><span class="c0">select a.Owner,a.Name as Dog_Name, b.Name as cat_Name</span></p><p class="c1"><span class="c0">from mat008.dogs as a </span></p><p class="c1"><span class="c0">left join mat008.cats as b</span></p><p class="c1"><span class="c0">on a.Owner=b.Owner;</span></p><p class="c1"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="271" src="images/image46.png" width="500"></p><p class="c7 c1"><span class="c8 c6">Figure 5.2 The output of a left outer join.</span></p><p class="c1"><span class="c6">The following code carries out a right outer join, the output of which is shown in Figure 5.3.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="5234f2efc7b3233f719394cae73360a3ae44c53e"></a><a href="#" name="97"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c11"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table merged_table as</span></p><p class="c1"><span class="c0">select a.Owner,a.Name as Dog_Name, b.Name as cat_Name</span></p><p class="c1"><span class="c0">from mat008.dogs as a </span></p><p class="c1"><span class="c0">right join mat008.cats as b</span></p><p class="c1"><span class="c0">on a.Owner=b.Owner;</span></p><p class="c1"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c7 c1"><img height="252" src="images/image07.png" width="464"></p><p class="c7 c1"><span class="c8 c6">Figure 5.3 The output of a right outer join.</span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c1"><span class="c6">The following code carries out a full outer join, the output of which is shown in Figure 5.4.</span></p><p class="c2 c1"><span class="c0"></span></p><a href="#" name="7ed569dd1a8a4bfe45187c6ba44d053f0aff9841"></a><a href="#" name="98"></a><table cellpadding="0" cellspacing="0" class="c12"><tbody><tr class="c26"><td class="c11"><p class="c1"><span class="c0">proc sql;</span></p><p class="c1"><span class="c0">create table merged_table as</span></p><p class="c1"><span class="c0">select a.Owner,a.Name as Dog_Name, b.Name as cat_Name</span></p><p class="c1"><span class="c0">from mat008.dogs as a </span></p><p class="c1"><span class="c0">full join mat008.cats as b</span></p><p class="c1"><span class="c0">on a.Owner=b.Owner;</span></p><p class="c1"><span class="c0">quit;</span></p></td></tr></tbody></table><p class="c2 c1 c5"><span class="c6"></span></p><p class="c2 c7 c1"><span class="c6"></span></p><p class="c7 c1"><img height="305" src="images/image33.png" width="562"></p><p class="c7 c1"><span class="c8 c6">Figure 5.4 The output of a fullouter join.</span></p><p class="c2 c7 c1"><span class="c6"></span></p><div><p class="c31 c1"><img height="66" src="images/image14.jpg" width="68"></p><p class="c2 c1 c31"><span class="c6"></span></p></div></body></html>